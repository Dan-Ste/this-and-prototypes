## `[[Prototype]]`
Практически у каждого объекта в JS есть свойство `[[Prototype]]`. Оно является ссылкой на другой объект. Когда мы обращаемся к свойству объекта и оно отсуствует в текущем объекте, операция `[[Get]]` будет продолжать искать свойство с таким же именем по цепочке прототипов объекта и вернет его, либо `undefined`, если оно не будет найдено. Также цикл `for..in` и оператор `in` будет проходить по всей цепочке прототипов в поисках свойства. 

## `Object.prototype`
Цепочка прототипов любого нормального (встроенного в язык и имеющего цепочку прототипов) объекта в JS заканчивается на объекте `Object.prototype`. Все объекты как бы наследуются от него или имеет его на верху цепочки прототипов. В этом объекте находится множество вспомогательных утилит, такиъ как `toString()`, `valueOf()` и тд

## Установка и затенение свойств.

```js 
myObject.foo = "bar";
```

При попытке присвоить значение в свойсво объекта происходит больше чем просто запись значение в новое свойство объекта. Операция `[[Get]]` сначала проходит по всей цепочке прототипов объекта и если одноименного свойства не было найдено, то создается новое свойство в объекте `myObject`. 
Но все не так просто, если одноименное свойство есть. В таком случае есть три варианта:
1. Если найденое в цепочке свойство изменяемое `writable: true`, то новое свойство запишется в объект `myObject`, как бы затеняя любое другое свойство в цепочке.
2. Если свойство неизменяемое `writable: false`, то подобная операция молча проигнорируется или завершится с ошибкой в `strict mode`. То есть затенения не произойдет
3. И третий вариант, если свойство в цепочке является сеттером, тогда этот сеттер вызовется и также не произойдет никакого затенения.

Второй вариант наиболее наиболее сбивающий с толку и училивающий ощущение классового наследования. Потому что при таком развитии событий кажется, что происходит наследование с копированием свойств. Еще более странно, что так проиходит только с опретором `=`, а исопльзуя `Object.defineProperty` можно затенеть свойство в прототипе, даже с дискриптором `writable: false`.

Вообще затенение с "методами" ведет к ужасному псевдо полиморфизму и нужно избегать его исопльзования, отдавая предпочнение более чистым паттернам о которых речь пойдет далее.

## "Классы"
Как уже говорилось, в JS нет никаких классов. Вызов функции с оператором `new` создает объект, у которого есть внутреннее, не перечисляемое свойство `[[Prototype]]`, которое указывает на объект прототип функции.
```js
function Foo() {
	// ...
}

var a = new Foo();

Object.getPrototypeOf( a ) === Foo.prototype; // true
```

Таким образом два объекта становятся связанны друг с другом посредством прототипов. И здесь нет никакого наследования, поскольку этот термин взят из ООП с классами. Но в JS нет классов и нет наследования, которое копирует все свойства и методы в новый объект. 
То есть термин прототипное наследование неправильный. После вызова функции с оператором new мы имеет новый объект связанный с объектом в свойстве prototype функции.
Причем такое поведение вызова функции почти что случайно. Это просто побочный эффект, а не вызов конструктора. Есть более очевидный способ создать связь между двумя объектами через `Object.create()`


