## `[[Prototype]]`
Практически у каждого объекта в JS есть свойство `[[Prototype]]`. Оно является ссылкой на другой объект. Когда мы обращаемся к свойству объекта и оно отсуствует в текущем объекте, операция `[[Get]]` будет продолжать искать свойство с таким же именем по цепочке прототипов объекта и вернет его, либо `undefined`, если оно не будет найдено. Также цикл `for..in` и оператор `in` будет проходить по всей цепочке прототипов в поисках свойства. 

## `Object.prototype`
Цепочка прототипов любого нормального (встроенного в язык и имеющего цепочку прототипов) объекта в JS заканчивается на объекте `Object.prototype`. Все объекты как бы наследуются от него или имеет его на верху цепочки прототипов. В этом объекте находится множество вспомогательных утилит, такиъ как `toString()`, `valueOf()` и тд

## Установка и затенение свойств.

```js 
myObject.foo = "bar";
```

При попытке присвоить значение в свойсво объекта происходит больше чем просто запись значение в новое свойство объекта. Операция `[[Get]]` сначала проходит по всей цепочке прототипов объекта и если одноименного свойства не было найдено, то создается новое свойство в объекте `myObject`. 
Но все не так просто, если одноименное свойство есть. В таком случае есть три варианта:
1. Если найденое в цепочке свойство изменяемое `writable: true`, то новое свойство запишется в объект `myObject`, как бы затеняя любое другое свойство в цепочке.
2. Если свойство неизменяемое `writable: false`, то подобная операция молча проигнорируется или завершится с ошибкой в `strict mode`. То есть затенения не произойдет
3. И третий вариант, если свойство в цепочке является сеттером, тогда этот сеттер вызовется и также не произойдет никакого затенения.

Второй вариант наиболее наиболее сбивающий с толку и училивающий ощущение классового наследования. Потому что при таком развитии событий кажется, что происходит наследование с копированием свойств. Еще более странно, что так проиходит только с опретором `=`, а исопльзуя `Object.defineProperty` можно затенеть свойство в прототипе, даже с дискриптором `writable: false`.

Вообще затенение с "методами" ведет к ужасному псевдо полиморфизму и нужно избегать его исопльзования, отдавая предпочнение более чистым паттернам о которых речь пойдет далее.

