## `[[Prototype]]`
Практически у каждого объекта в JS есть свойство `[[Prototype]]`. Оно является ссылкой на другой объект. Когда мы обращаемся к свойству объекта и оно отсуствует в текущем объекте, операция `[[Get]]` будет продолжать искать свойство с таким же именем по цепочке прототипов объекта и вернет его, либо `undefined`, если оно не будет найдено. Также цикл `for..in` и оператор `in` будет проходить по всей цепочке прототипов в поисках свойства. 

## `Object.prototype`
Цепочка прототипов любого нормального (встроенного в язык и имеющего цепочку прототипов) объекта в JS заканчивается на объекте `Object.prototype`. Все объекты как бы наследуются от него или имеет его на верху цепочки прототипов. В этом объекте находится множество вспомогательных утилит, такиъ как `toString()`, `valueOf()` и тд

## Установка и затенение свойств.

```js 
myObject.foo = "bar";
```

При попытке присвоить значение в свойсво объекта происходит больше чем просто запись значение в новое свойство объекта. Операция `[[Get]]` сначала проходит по всей цепочке прототипов объекта и если одноименного свойства не было найдено, то создается новое свойство в объекте `myObject`. 
Но все не так просто, если одноименное свойство есть. В таком случае есть три варианта:
1. Если найденое в цепочке свойство изменяемое `writable: true`, то новое свойство запишется в объект `myObject`, как бы затеняя любое другое свойство в цепочке.
2. Если свойство неизменяемое `writable: false`, то подобная операция молча проигнорируется или завершится с ошибкой в `strict mode`. То есть затенения не произойдет
3. И третий вариант, если свойство в цепочке является сеттером, тогда этот сеттер вызовется и также не произойдет никакого затенения.

Второй вариант наиболее наиболее сбивающий с толку и училивающий ощущение классового наследования. Потому что при таком развитии событий кажется, что происходит наследование с копированием свойств. Еще более странно, что так проиходит только с опретором `=`, а исопльзуя `Object.defineProperty` можно затенеть свойство в прототипе, даже с дискриптором `writable: false`.

Вообще затенение с "методами" ведет к ужасному псевдо полиморфизму и нужно избегать его исопльзования, отдавая предпочнение более чистым паттернам о которых речь пойдет далее.

## "Классы"
Как уже говорилось, в JS нет никаких классов. Вызов функции с оператором `new` создает объект, у которого есть внутреннее, не перечисляемое свойство `[[Prototype]]`, которое указывает на объект прототип функции.
```js
function Foo() {
	// ...
}

var a = new Foo();

Object.getPrototypeOf( a ) === Foo.prototype; // true
```

Таким образом два объекта становятся связанны друг с другом посредством прототипов. И здесь нет никакого наследования, поскольку этот термин взят из ООП с классами. Но в JS нет классов и нет наследования, которое копирует все свойства и методы в новый объект. 
То есть термин прототипное наследование неправильный. После вызова функции с оператором new мы имеет новый объект связанный с объектом в свойстве prototype функции.
Причем такое поведение вызова функции почти что случайно. Это просто побочный эффект, а не вызов конструктора. Есть более очевидный способ создать связь между двумя объектами через `Object.create()`

## Конструктор

То, что мы используем оператор new и то, что вызов функции похож на вызов метода конструктора класса, заставляет нас думать что в JS есть классы. Более того, у прототипа функции есть свойство constructor, которое указывает на функцию и у нового объекта есть такое же свойство
```js
function Foo() {
	// ...
}

Foo.prototype.constructor === Foo; // true

var a = new Foo();
a.constructor === Foo; // true
```

Еще в JS принято называть функции, которые будут вызваны с new с заглавной буквы и даже существуют правила линтеров следящие за этим. И это притом, что для движка абсолютно не важно, заглавная или нет первая буква названия функции. 
Сама функция не является конструктором, но если ее вызвать с оператором new, то это будет вызов конструктора, побочным эффектом которого оказывается новый объект.

## Механика
Свойство constructor нового объекта очень не надежно. Кажется интуитивным считать, что она указывает на то, что сконструировало объект. Но дело в том, что этого свойства нет в новом объекте. Оно берется из цепочки прототипов и по умолчанию указывает на свойство constructor объекта prototype функции, вызванной с оператором new. Но это свойство, как и целиком объект prototype можно перезаписать и тогда можно столкнутся с подобной ситуацией 
```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // create a new prototype object

var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```
Теперь этого свойства нет в прототипе функции и по цепочке прототипов мы попадаем в самый верхний в цепочке прототипов объект Object.prototype, свойство constructor которого указывает на встроенную функцию Object()

Можно сказать, что свойство constuctor крайне не надежно и стоит избегать его использования.

