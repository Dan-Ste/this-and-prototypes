Чтобы ответить на вопрос, что же такое this, для начала нам нужно найти место возова функция. Но некоторые паттерны написания кода на JS могут скрыть от нас этот факт. Обычно это место можно обнаружить проанализировав стек вызовов функции. Проанализировав его мы можем найти места вызова нашей функции.

Найдя место вызова функции мы должны определить, какое из 4 правил связывания контекста был применен в случае этого вызова:

1. Связывание контекста по умолчанию.

  Если произведет обыкновенный вызов функции, то прозсходит связывание по умолчанию и this указывает на глобальный объект (window в браузере). Тем не менее в случае запуска нашего кода с директивой `strict mode` глобальный объект не доступен для модификации и this = undefined.
  ```js
  function foo() {
    console.log( this.a );
  }

  var a = 2;

  foo(); // 2
  ```
  ```
  function foo() {
    "use strict";

    console.log( this.a );
  }

  var a = 2;

  foo(); // TypeError: `this` is `undefined`
  ```

2. Неявное связывание

Когда функция присвоена свойству объекта, явно или по ссылки, говорят что функция принадлежит объекту и срабатывает скрытое связывание контекста. В этом случае this указывает на этот объект.

Но на самом деле функция не принадлежит объекту. Мы вызываем функцию через точку из объекта (как метод) и поэтому говорят, что функция как бы принадлежит объекту. Важно само место вызова функции. И в данном случае видно, что функция вызвана не обычным способов, а через объект.

```js
  function foo() {
    console.log( this.a );
  }

  var obj = {
    a: 2,
    foo: foo
  };

  obj.foo(); // 2
```
Также this будет указывать на последний объект в цепочке вызова функции
```js
function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42
```

Этот способ связывания вызывает много разочарования у разработчиков, потому что контект легко потерять. 
Например сохранив ссылку на функцию в объекте в другой переменой и вызвав ее обычным способом, будет применено связывание по умолчанию.
```js
  function foo() {
    console.log( this.a );
  }

  var obj = {
    a: 2,
    foo: foo
  };

  var bar = obj.foo; // function reference/alias!

  var a = "oops, global"; // `a` also property on global object

  bar(); // "oops, global"
```
Но чаще всего такое может происходить, при передачи нашего метода в виде колбека в функция. В этом случае он тоже присваеватся в новую переменную и вызывается как обычная функция. То же самое, чо и в первом примере.
```js
  function foo() {
    console.log( this.a );
  }

  function doFoo(fn) {
    // `fn` is just another reference to `foo`

    fn(); // <-- call-site!
  }

  var obj = {
    a: 2,
    foo: foo
  };

  var a = "oops, global"; // `a` also property on global object

  doFoo( obj.foo ); // "oops, global"
```
Также различные библиотеки специально меняют контекст передаваемого нами колбека и мы не можем повлиять на то, как наша функция будет вызвана "внутри" и поэтому тут нужно быть аккуратнее. Но мы можем жестко задать контект функции сами.

3. Явное связывание

