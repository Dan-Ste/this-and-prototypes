Чтобы ответить на вопрос, что же такое this, для начала нам нужно найти место возова функция. Но некоторые паттерны написания кода на JS могут скрыть от нас этот факт. Обычно это место можно обнаружить проанализировав стек вызовов функции. Проанализировав его мы можем найти места вызова нашей функции.

Найдя место вызова функции мы должны определить, какое из 4 правил связывания контекста был применен в случае этого вызова:

1. Связывание контекста по умолчанию.

  Если произведет обыкновенный вызов функции, то прозсходит связывание по умолчанию и this указывает на глобальный объект (window в браузере). Тем не менее в случае запуска нашего кода с директивой `strict mode` глобальный объект не доступен для модификации и this = undefined.
  ```js
  function foo() {
    console.log( this.a );
  }

  var a = 2;

  foo(); // 2
  ```
  ```
  function foo() {
    "use strict";

    console.log( this.a );
  }

  var a = 2;

  foo(); // TypeError: `this` is `undefined`
  ```

2. Неявное связывание

Когда функция присвоена свойству объекта, явно или по ссылки, говорят что функция принадлежит объекту и срабатывает скрытое связывание контекста. В этом случае this указывает на этот объект.

Но на самом деле функция не принадлежит объекту. Мы вызываем функцию через точку из объекта (как метод) и поэтому говорят, что функция как бы принадлежит объекту. Важно само место вызова функции. И в данном случае видно, что функция вызвана не обычным способов, а через объект.

```js
  function foo() {
    console.log( this.a );
  }

  var obj = {
    a: 2,
    foo: foo
  };

  obj.foo(); // 2
```
Также this будет указывать на последний объект в цепочке вызова функции
```js
function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42
```

Этот способ связывания вызывает много разочарования у разработчиков, потому что контект легко потерять. 
Например сохранив ссылку на функцию в объекте в другой переменой и вызвав ее обычным способом, будет применено связывание по умолчанию.
```js
  function foo() {
    console.log( this.a );
  }

  var obj = {
    a: 2,
    foo: foo
  };

  var bar = obj.foo; // function reference/alias!

  var a = "oops, global"; // `a` also property on global object

  bar(); // "oops, global"
```
Но чаще всего такое может происходить, при передачи нашего метода в виде колбека в функция. В этом случае он тоже присваеватся в новую переменную и вызывается как обычная функция. То же самое, чо и в первом примере.
```js
  function foo() {
    console.log( this.a );
  }

  function doFoo(fn) {
    // `fn` is just another reference to `foo`

    fn(); // <-- call-site!
  }

  var obj = {
    a: 2,
    foo: foo
  };

  var a = "oops, global"; // `a` also property on global object

  doFoo( obj.foo ); // "oops, global"
```
Также различные библиотеки специально меняют контекст передаваемого нами колбека и мы не можем повлиять на то, как наша функция будет вызвана "внутри" и поэтому тут нужно быть аккуратнее. Но мы можем жестко задать контект функции сами.

3. Явное связывание

При неявном связывании нам нужно сделать ссылку на функции в свойстве объекта. Для того чтобы связать контекст функции с объектом без этого, можно использовать явное связывание через методы call или aplly из прототипа функций. Первым аргументом они принимают объект, который будет контекстом функции.
```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```
Но это не решает проблемы потери контекста при передаче функции обратного вызова (колбека). Для этого можно жестко обернут вызов с явным связыванием функцию.
```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj );
};

bar(); // 2
setTimeout( bar, 100 ); // 2

// `bar` hard binds `foo`'s `this` to `obj`
// so that it cannot be overriden
bar.call( window ); // 2
```
Этот паттерн называется жестким связыванием или bind и мы можем написать свою функцию хелпер bind:
```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

// simple `bind` helper
function bind(fn, obj) {
	return function() {
		return fn.apply( obj, arguments );
	};
}

var obj = {
	a: 2
};

var bar = bind( foo, obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```
Но посколько жесткое связывание очень популярный паттерн, его добавили в прототип функций и нам необязательно писать свой хелпер:
```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = foo.bind( obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

3. Связывание с оператором new

Четвертое и последнее правило для связывание контекста требует более глубокого понимания работы операторы new в JavaScpipt. В классических ОО языках при вызове класса с этим оператором вызовется конструктор класса и вернется экземпляр класса.
В JS это работает иначе и не имеет к вышеизложенному никакого отношения. В JS нет никаких специальных конструкторов. С оператором new используются самые обыкновенные функции (они не конструкторы), поведение которых несколько меняется при вызове с оператором new. Они не привязаны к классам (потому что их нет в JS) и также не создают экземпляров классов. 
При вызове функции с операторм new происходит так называемый вызов конструктора, создающий новый объект и делающий его контектом вызываемой функции. Затем этот новый объект возвращается функцией.
```js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2
```

 ## Приоритет правил связывания
 Мы выяснили, что для того чтобы определить контекст функции, нужно понять как она была вызвана. Но иногда к функции могут применятся сразу несколько вариантов связывания и тогда нам необходимо знать их приоритет. Самый низкий приортитет имеет связывание по умолчанию.

 ```js
 function foo() {
	console.log( this.a );
}

var obj1 = {
	a: 2,
	foo: foo
};

var obj2 = {
	a: 3,
	foo: foo
};

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
 ```
 Явное связывание имеет приоритет над неявным.
 И опуская технические детали, которые на самом деле сложны, скажем, что связывание с new имеет наибольший приоритет.
 ```js
 function foo(something) {
	this.a = something;
}

var obj1 = {};

var bar = foo.bind( obj1 );
bar( 2 );
console.log( obj1.a ); // 2

var baz = new bar( 3 );
console.log( obj1.a ); // 2
console.log( baz.a ); // 3
 ```
