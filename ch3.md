Вопреки расхожему мнению, не все в JS объект. В JS есть 7 типов данных, 6 из которых примитивные (string, number, boolean, null, undefined и Symbol), а также составной тип данных - object.

Объект можно создать литеральной и конструирующей формой. При исопльзовании любой формы результатом является идентичный объект, но литеральная форма позволяет задавать множество свойств сразу, поэтому она предпочтительнее.

Функция это подтип объекта, но который можно вызвать. Массив также подтип объекта с более организованной структурой. Существуют также другие встроенные в язык подтипы объекта:
- String
- Number
- Boolean
- Function
- Array
- Date
- RegExp
- Error

Первые три кажется связаны с примитивными типами и по аналогии с Java хочется назвать их классами, но это просто функции, которые могут быть вызваны как конструкторы с оператором new.
Например примитив строки и объект созданный с помощью функции коструктора строки имеют разные типы. Но прототип функции конструктора имеет различный полезный функционал для работы со строками (или числами, или булевыми значениями). Чтобы можно было легко использовать этот функционал с примитивами, язык автоматически оборачивает примитив нужным объектом и мы получаем доступ к нужным нам методам.
Это называется boxing.
Примитивы null и undefined не имеют объекта-обертки. А подтип Date наоборот не имеет примитивной формы.
В тоже время Object, Array, Function и RegExp имеют обе формы, но все зависимости от того, какую мы будет использовать в результате получится тип - object. В большинстве случаев нужно использовать литеральные формы записи, а конструирующие только в случае если нам нужны какие-то дополнительные настройки при создании.

## Контент объекта

В объекте могут хранится данные любого типа в специальных именованных местах, называемых свойствами. Но это не значит, что они действительно хранятся в объекте. В объекте хранятся свойства, которые указывают/ссылаются на значения, которые могут находится в рахных местах в зависимости от реализации программы.

Для получения значения свойства можно использовать операторы `.` или `[ ]`. С помощью квадратных скобок можно получить доступ к свойсту с невалидным названием через строку - `['Super-Fun!']`. Также с помощью этого оператора можно программно вычислять имя свойства объекта.

Имена свойств объекта всегда являются строками. Если мы используем в качетсве свойства другой тип данных, то он сначала автоматически свконвертируется в строку.

## Вычисляемые имена свойств

Также оператор `[ ]` может использоваться для вычисления имен свойств при литеральном объявление объекта

```js
var prefix = "foo";

var myObject = {
	[prefix + "bar"]: "hello",
	[prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

## Свойства или методы

Если значение свойства является функция, то такое свойство часто называют методом. Но для этого нет никаких причин, потому что функция не принадлежит объекту и ничем не отличается от любой другой функции. То есть мы не вызываем метод объекта, а получаем доступ к свойству объекта, значением которого является функция, которую мы вызываем.

## Массивы

Массивы в JS тоже объекты. В них также могут хранится любые типы данных, но структура массива предпологает нумерованную индексацию положительными числами. Но мы может добавить совйство массиву сс любым именем. Мы даже можем использовать массив для хранение данных в виде ключ/значение, как обычный объект. Но это плохая идея, так как массивы имеют специальное поведение и оптимизацию для работы с нумерованными индексами.

## Дублирование объекта

В JS не все так просто с копированием объектов. Это нетривиальная задача, потому что не всегда понятно должно ли происходить поверхностное копирование или глубокое. Существуют разные библиотеки, которые решают этот вопрос по своему. Но существуют несколько способов сделать это. Первый с использованием JSON

```js
var newObj = JSON.parse( JSON.stringify( someObj ) );
```
Но этот способ предпологает, что объект должен быть валиден для преобразования в JSON.

Второй способ появился в ES6 - `Object.assign(...)`. Он осуществляет поверхностную копию объекта с помощью оператора присваивания `=`

```
var newObj = Object.assign( {}, myObject );

newObj.a;						// 2
newObj.b === anotherObject;		// true
newObj.c === anotherArray;		// true
newObj.d === anotherFunction;	// true
```

## Дискримпторы или описания свойств

В ES5 появились дискрипторы свойств позволяющие задать свойтву дополнительные характеристики: writable, configurable, enumerable:

```js
var myObject = {
	a: 2
};

Object.getOwnPropertyDescriptor( myObject, "a" );
// {
//    value: 2,
//    writable: true,
//    enumerable: true,
//    configurable: true
// }
```

Их можно задать вручную используя `Object.defineProperty(...)`:

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: true,
	enumerable: true
} );

myObject.a; // 2
```

Это позволяет задать описательные характеристики свойства объекта явно, если нам это необходимо.

## Writable

Контролирует возможность изменения свойства
```js
"use strict";

var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: false, // not writable!
	configurable: true,
	enumerable: true
} );

myObject.a = 3; // TypeError
```

## Configurable

Контроллирует настраивоемость свойства. Если выставлено в `false`, то больше нельзя обновить дискриптор свойства с помощью `defineProperty` (TypeError при попытке). Также это свойство нельзя будет удалить с помощью оператора delete (Молча не удалит свойство).

## Enumerable

Определяет появится ли свойство при перечислении, например через `for..in` или `Object.keys()`

## Неизменяемость (иммутабельность)

Все стандартные способы сделать объект неизменяемым, делают его таковым только поверхностно. То есть работают для самого объекта и/или его свойств, но не для ссылок на объекты в его свойствах. Они останутся изменяемыми и чтобы сделать их тоже неизменяемыми нужно применить к ним те же способы.

1. Можно сделать свойство объекта константой задав `false` его дискрипторам writable и configurable

2. Можно запретить расширения объекта свойствами с помощью `Object.preventExtensions(...)`

3. Можно запечатать объект с помощью `Obejct.seal(...)`. Это запретит расширения объекта вызвав на нем `Object.preventExtensions(...)`, а также проставит всем свойтсвам дискриптор `configurable: false` (то есть их нельзя перенастроить и удалить). Но все же свойства можно обновить.

4. Заморозка объекта при помощи `Object.freeze(...)`, который вызывает под капотом `Obejct.seal()`, а также проставляет свойствам дискриптор writable в `false`. Это самый высоких уровень неизвеняемости которые можно получить стандартными средствами. Но нужно помнить, что все внутренние ссылки на другие объекты останутся изменяемыми. И если мы хотим сделать их тоже неизменяемыми, то можно вызывать `Object.freeze(...)` на объекте рекурсивно. Но следует быть осторожным, так как это может быть неоптимальным, а также заморозить объекты, которые мы возможно не хотели замораживать.

## [[Get]]

При обращении к свойству объекту происходит не просто возврат этого свойства из объекта, а вызов функции `[[Get]]()` с именем этого свойства. Если такого свойства в объекте нет, то оно будет искаться по цепочке прототипов, если они есть. Если свойство не было найдено, не проихойдет ошибки, как при обращении к несуществующей переменной, а вернется `undefined`

## [[Put]]

Также при присвоении значение вызовется функция `[[Put]]`, которая сначала обратиться к сеттеру свойства, если он есть, если нет, то прочитает дискриптор writable и если он не false, то запищет новое значение свойства.

## Геттеры и Сеттеры

Мы можем переопределить часть операций по умолчанию осуществляемых `[[Get]]` и `[[Set]]`, но только на уровне свойств, а не всего объекта. Для этого существует еще два специальных дискриптора доступа свойства - get и set. Их можно задать как в явной, так и в неявной форме. 

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return 2;
	}
};

Object.defineProperty(
	myObject,	// target
	"b",		// property name
	{			// descriptor
		// define a getter for `b`
		get: function(){ return this.a * 2 },

		// make sure `b` shows up as an object property
		enumerable: true
	}
);

myObject.a; // 2

myObject.b; // 4
```

Если не задать сеттер, то геттер очевидно всегда будет возвращать одно и то же значение, поэтому чтобы не возникало такого недоразумения чаще всего лучше объявлять оба дискриптора. 

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return this._a_;
	},

	// define a setter for `a`
	set a(val) {
		this._a_ = val * 2;
	}
};

myObject.a = 2;

myObject.a; // 4
```

## Наличие свойства

Обращение к свойству объекта может вернуть `undefined`, если мы явно зададим ему такое значение, либо если свойство не существует вовсе. Чтобы точно проверить наличие свойства можно воспользоваться оператором `in`, либо свойством из прототипа объектов `myObject.hasOwnProperty()`. Первый способ будет искать наличие свойства по всей цепочке прототипов, а второй только если `myObject` имеет такое свойство.

//
Цикл `for .. of` вызывает функцию `next()` внутреннего объекта итератора `Symnol.iterator`, если он есть в объекте, который возвращает значения перечисляемого объекта, в противоположность циклу `for .. in`, который возвращает свойства объекта.  Такой итератор есть в ES6 в массивах по умолчанию. В объектах его нет и если нужно сделать итерацию по объекту и получить все значения его свойств, то итератор нужно писать самостоятельно.
//

