Вопреки расхожему мнению, не все в JS объект. В JS есть 7 типов данных, 6 из которых примитивные (string, number, boolean, null, undefined и Symbol), а также составной тип данных - object.

Объект можно создать литеральной и конструирующей формой. При исопльзовании любой формы результатом является идентичный объект, но литеральная форма позволяет задавать множество свойств сразу, поэтому она предпочтительнее.

Функция это подтип объекта, но который можно вызвать. Массив также подтип объекта с более организованной структурой. Существуют также другие встроенные в язык подтипы объекта:
- String
- Number
- Boolean
- Function
- Array
- Date
- RegExp
- Error

Первые три кажется связаны с примитивными типами и по аналогии с Java хочется назвать их классами, но это просто функции, которые могут быть вызваны как конструкторы с оператором new.
Например примитив строки и объект созданный с помощью функции коструктора строки имеют разные типы. Но прототип функции конструктора имеет различный полезный функционал для работы со строками (или числами, или булевыми значениями). Чтобы можно было легко использовать этот функционал с примитивами, язык автоматически оборачивает примитив нужным объектом и мы получаем доступ к нужным нам методам.
Это называется boxing.
Примитивы null и undefined не имеют объекта-обертки. А подтип Date наоборот не имеет примитивной формы.
В тоже время Object, Array, Function и RegExp имеют обе формы, но все зависимости от того, какую мы будет использовать в результате получится тип - object. В большинстве случаев нужно использовать литеральные формы записи, а конструирующие только в случае если нам нужны какие-то дополнительные настройки при создании.

## Контент объекта

В объекте могут хранится данные любого типа в специальных именованных местах, называемых свойствами. Но это не значит, что они действительно хранятся в объекте. В объекте хранятся свойства, которые указывают/ссылаются на значения, которые могут находится в рахных местах в зависимости от реализации программы.

Для получения значения свойства можно использовать операторы `.` или `[ ]`. С помощью квадратных скобок можно получить доступ к свойсту с невалидным названием через строку - `['Super-Fun!']`. Также с помощью этого оператора можно программно вычислять имя свойства объекта.

Имена свойств объекта всегда являются строками. Если мы используем в качетсве свойства другой тип данных, то он сначала автоматически свконвертируется в строку.

## Вычисляемые имена свойств

Также оператор `[ ]` может использоваться для вычисления имен свойств при литеральном объявление объекта

```js
var prefix = "foo";

var myObject = {
	[prefix + "bar"]: "hello",
	[prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

## Свойства или методы

Если значение свойства является функция, то такое свойство часто называют методом. Но для этого нет никаких причин, потому что функция не принадлежит объекту и ничем не отличается от любой другой функции. То есть мы не вызываем метод объекта, а получаем доступ к свойству объекта, значением которого является функция, которую мы вызываем.

## Массивы

Массивы в JS тоже объекты. В них также могут хранится любые типы данных, но структура массива предпологает нумерованную индексацию положительными числами. Но мы может добавить совйство массиву сс любым именем. Мы даже можем использовать массив для хранение данных в виде ключ/значение, как обычный объект. Но это плохая идея, так как массивы имеют специальное поведение и оптимизацию для работы с нумерованными индексами.

## Дублирование объекта

В JS не все так просто с копированием объектов. Это нетривиальная задача, потому что не всегда понятно должно ли происходить поверхностное копирование или глубокое. Существуют разные библиотеки, которые решают этот вопрос по своему. Но существуют несколько способов сделать это. Первый с использованием JSON

```js
var newObj = JSON.parse( JSON.stringify( someObj ) );
```
Но этот способ предпологает, что объект должен быть валиден для преобразования в JSON.

Второй способ появился в ES6 - `Object.assign(...)`. Он осуществляет поверхностную копию объекта с помощью оператора присваивания `=`

```
var newObj = Object.assign( {}, myObject );

newObj.a;						// 2
newObj.b === anotherObject;		// true
newObj.c === anotherArray;		// true
newObj.d === anotherFunction;	// true
```

